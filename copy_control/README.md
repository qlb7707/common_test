#C++拷贝控制
如果一个类没有定义拷贝控制成员，编译器会自动为它定义缺失的操作。因此很多类会忽略这些拷贝控制操作。但是对于一些类来说，依赖于这些操作的默认定义会导致灾难。通常，实现这些拷贝控制操作最困难的地方是**首先认识到什么时候需要定义这些操作**

##拷贝、赋值与销毁

###拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。第一个参数通常是const的引用。支持隐式调用，因此不能为explicit。

####合成拷贝构造函数
如果没有为类定义拷贝构造函数，编译器会为我们定义一个。一般情况下合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建对对象中，编译器从给定的对象中依次将每个**非static成员**拷贝到正在创建的对象中。

**成员如何拷贝**

- 类：使用拷贝构造函数
- 内置类型：直接拷贝
- 数组：逐元素拷贝

####拷贝初始化

**拷贝构造发生的情况**

- 使用＝定义变量
- 将一个对象作为实参传递给非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 初始化标准库容器或调用insert或push成员

拷贝构造函数用来初始化非引用类型的参数，这一性质揭示了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，则永远调用不成功－－－为了调用拷贝构造函数，必须拷贝它的实参，但未来拷贝实参，又需要调用拷贝构造函数。

####拷贝初始化的限制


如果我们使用的初始化值要求通过一个explicit构造函数进行类型转换那么使用拷贝初始化还是直接初始化就不是无关紧要的。

```
vector<int> v1(10);   //正确，直接初始化
vector<int> v1 = 10;  //错误，接受大小参数的构造函数是explicit的
void f(vector<int>);
f(10);                //错误
f(vector<int>(10));   //正确
```

###拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

####赋值重载运算符

重载运算符本质上是函数，其名字由operator关键字后接运算符号组成。重载运算符的参数表示表示运算符的运算对象。某些运算符包括赋值运算符，必须定义为成员函数，左侧运算对象绑定到隐式的this参数，二元运算符右侧运算对象作为显示参数传递。赋值运算符通常返回一个指向其左侧运算对象的引用。**标准库通常要求保存在容器中的类型具有赋值运算符，返回值是指向左侧运算对象的引用**


####合成拷贝赋值运算符
如果未定义赋值运算符，编译器会生成一个合成赋值运算符。通常会将右侧运算对象的非static成员赋予左侧运算对象的对应成员，这是通过拷贝赋值运算来完成。

###析沟函数
析构函数释放对象使用的资源，并销毁对象的非static成员。由于析构函数不接受参数，因此它不能被重载，对于一个类，有唯一的析构函数。

##拷贝控制和资源管理

##交换操作

##拷贝控制示例

##动态内存管理类
##对象移动
