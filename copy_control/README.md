#C++拷贝控制
如果一个类没有定义拷贝控制成员，编译器会自动为它定义缺失的操作。因此很多类会忽略这些拷贝控制操作。但是对于一些类来说，依赖于这些操作的默认定义会导致灾难。通常，实现这些拷贝控制操作最困难的地方是**首先认识到什么时候需要定义这些操作**

##拷贝、赋值与销毁

###拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。第一个参数通常是const的引用。支持隐式调用，因此不能为explicit。

####合成拷贝构造函数
如果没有为类定义拷贝构造函数，编译器会为我们定义一个。一般情况下合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建对对象中，编译器从给定的对象中依次将每个**非static成员**拷贝到正在创建的对象中。

**成员如何拷贝**

- 类：使用拷贝构造函数
- 内置类型：直接拷贝
- 数组：逐元素拷贝

####拷贝初始化

**拷贝构造发生的情况**

- 使用＝定义变量
- 将一个对象作为实参传递给非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 初始化标准库容器或调用insert或push成员

拷贝构造函数用来初始化非引用类型的参数，这一性质揭示了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，则永远调用不成功－－－为了调用拷贝构造函数，必须拷贝它的实参，但未来拷贝实参，又需要调用拷贝构造函数。

####拷贝初始化的限制


如果我们使用的初始化值要求通过一个explicit构造函数进行类型转换那么使用拷贝初始化还是直接初始化就不是无关紧要的。

```
vector<int> v1(10);   //正确，直接初始化
vector<int> v1 = 10;  //错误，接受大小参数的构造函数是explicit的
void f(vector<int>);
f(10);                //错误
f(vector<int>(10));   //正确
```

###拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

####赋值重载运算符

重载运算符本质上是函数，其名字由operator关键字后接运算符号组成




##拷贝控制和资源管理

##交换操作

##拷贝控制示例

##动态内存管理类
##对象移动
