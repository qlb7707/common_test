#C++拷贝控制
如果一个类没有定义拷贝控制成员，编译器会自动为它定义缺失的操作。因此很多类会忽略这些拷贝控制操作。但是对于一些类来说，依赖于这些操作的默认定义会导致灾难。通常，实现这些拷贝控制操作最困难的地方是**首先认识到什么时候需要定义这些操作**

##拷贝、赋值与销毁

###拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。第一个参数通常是const的引用。支持隐式调用，因此不能为explicit。

####合成拷贝构造函数
如果没有为类定义拷贝构造函数，编译器会为我们定义一个。一般情况下合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建对对象中，编译器从给定的对象中依次将每个**非static成员**拷贝到正在创建的对象中。

**成员如何拷贝**

- 类：使用拷贝构造函数
- 内置类型：直接拷贝
- 数组：逐元素拷贝

####拷贝初始化

**拷贝构造发生的情况**

- 使用＝定义变量
- 将一个对象作为实参传递给非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 初始化标准库容器或调用insert或push成员

拷贝构造函数用来初始化非引用类型的参数，这一性质揭示了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，则永远调用不成功－－－为了调用拷贝构造函数，必须拷贝它的实参，但未来拷贝实参，又需要调用拷贝构造函数。

####拷贝初始化的限制


如果我们使用的初始化值要求通过一个explicit构造函数进行类型转换那么使用拷贝初始化还是直接初始化就不是无关紧要的。

```
vector<int> v1(10);   //正确，直接初始化
vector<int> v1 = 10;  //错误，接受大小参数的构造函数是explicit的
void f(vector<int>);
f(10);                //错误
f(vector<int>(10));   //正确
```

###拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

####赋值重载运算符

重载运算符本质上是函数，其名字由operator关键字后接运算符号组成。重载运算符的参数表示表示运算符的运算对象。某些运算符包括赋值运算符，必须定义为成员函数，左侧运算对象绑定到隐式的this参数，二元运算符右侧运算对象作为显示参数传递。赋值运算符通常返回一个指向其左侧运算对象的引用。**标准库通常要求保存在容器中的类型具有赋值运算符，返回值是指向左侧运算对象的引用**


####合成拷贝赋值运算符
如果未定义赋值运算符，编译器会生成一个合成赋值运算符。通常会将右侧运算对象的非static成员赋予左侧运算对象的对应成员，这是通过拷贝赋值运算来完成。

###析沟函数

析构函数释放对象使用的资源，并销毁对象的非static成员。由于析构函数不接受参数，因此它不能被重载，对于一个类，有唯一的析构函数。

####析构函数完成什么工作
在一个析构函数中先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁。通常析构函数释放对象在生存期分配的所有资源。销毁类类型的成员需要执行成员自己的析构函数。

####什么时候调用析构函数

无论何时销毁一个对象，都会自动调用析构函数。

- 变量在离开其作用与时被销毁
- 当一个变量被销毁时，其成员被销毁
- 容器或数组被销毁时，其元素被销毁
- 对动态分配的对象，当对应指向它的指针应用delete时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

```
{
    Sales_data *p = new Sales_data;       //p是一个内置指针
    auto p2 = make_shared<Sales_data>();  //p2是一个shared_ptr
    Sales_data item(*p);                  //拷贝构造，把*p拷贝到item         
    vector<Sales_data> vec;               //局部对象
    vec.push_back(*p2);                   //拷贝p2指向点对象
    delete p;                             //对p指向的对象执行析构函数
}
//退出局部作用域；对item、p2和vec调用析构函数
//销毁p2会递减其引用计数；如果引用计数变为0，对象被释放
//销毁vec会销毁它的元素
```

####合成析构函数

当一个类未定义其析构函数时，编译器会为它定义一个合成析构函数。对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体为空。

析构函数本身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段被销毁的。

###三／五法则

三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符、析构函数。新标准下还可以定义**移动构造函数**和**移动赋值运算符**。

- 需要析构函数的类几乎可以肯定也需要一个拷贝构造函数和拷贝赋值运算符
- 需要拷贝构造函数的类几乎可以肯定也需要一个拷贝赋值运算符，反之亦然

###使用＝default

我们只能对具有合成版本的成员函数使用＝default（即默认构造函数和拷贝控制成员）

###阻止拷贝

有些类（如iostream）拷贝构造函数和拷贝赋值运算没有合理的意义，在此情况下，需要采取某种机制阻止拷贝或赋值，不定义拷贝控制成员是无效的，因为编译器会自动合成。

####定义删除的函数
新标准下可以将拷贝构造函数和拷贝赋值运算符定义成删除的函数来阻止拷贝。
删除的函数：虽然声明了他们，但是不能以任何方式使用它们。在函数后面加＝delete来指出我们希望它将定义为删除的：

```
struct NoCopy{
    NoCopy() = default;                          //使用合成的默认构造函数
    NoCopy(const &NoCopy) = delete;              //阻止拷贝
    NoCopy& operator=(const NoCopy&) = delete;   //阻止赋值
    ~NoCopy() = default;                         //使用合成的析构函数
}
```

**与＝default的不同：**
- ＝delete必须出现在函数第一次声明的时候
- 可以对任何函数指定＝delete，＝default只能用于编译器可以合成的默认构造函数或拷贝控制成员

#####析构函数不能是删除的成员

如果析构函数被删除，就无法销毁此类型的对象。

#####合成的拷贝控制成员可能是删除的

对于某些类来说，合成的成员定义为删除的。
- 如果类的某个成员的析构函数是删除的或不可访问的，那么类的合成析构函数被定义为删除的。
- 如果类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
- 如果类的某个成员的析构函数是删除的或不可访问的，或类有一个引用成员，它没有类内初始化器或类有一个const成员它没有类内初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。

本质上这些规则的含义为：如果类有数据成员不能默认构造、拷贝、复制、销毁，则对应的成员函数将被定义成删除的。

#####private拷贝控制

新标准发布前，类通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的。未了阻止友元和合成员函数进行拷贝，我们将这些拷贝控制成员声明为private但不定义他们。

##拷贝控制和资源管理
通常管理类外资源的类必须定义拷贝控制成员。首先必须确定此类型对象的拷贝语义，通常有两种选择，使类的行为看起来像一个值或者一个指针。

- 行为像一个值，有自己的状态，拷贝对象时副本和原对象是完全独立的；
- 行为像指针，拷贝对象时，副本和原对象啊使用相同的底层数据，改变副本也会改变原对象。

###行为像值的类


```
class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):ps(new std::string(s)),i(0){}

}
```

##交换操作

##拷贝控制示例

##动态内存管理类
##对象移动
